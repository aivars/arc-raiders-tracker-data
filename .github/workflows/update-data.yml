name: Update Game Data

on:
  schedule:
    # Run daily at 3:00 AM UTC
    - cron: '0 3 * * *'
  workflow_dispatch: # Allow manual trigger

permissions:
  contents: write

jobs:
  update-data:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Checkout RaidTheory data
        uses: actions/checkout@v4
        with:
          repository: RaidTheory/arcraiders-data
          path: raidtheory-data

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Process and build database
        run: |
          node << 'EOF'
          const fs = require('fs');
          const path = require('path');

          // Read all item files
          const itemsDir = './raidtheory-data/items';
          if (!fs.existsSync(itemsDir)) {
            throw new Error(`Items directory not found: ${itemsDir}`);
          }

          const files = fs.readdirSync(itemsDir).filter(f => f.endsWith('.json'));
          if (files.length === 0) {
            throw new Error('No item files found in RaidTheory data');
          }

          const items = [];
          const recycleMap = {}; // For reverse lookup

          // Helper to extract English text from localized strings
          const getEnglish = (field) => {
            if (!field) return null;
            if (typeof field === 'string') return field;
            if (typeof field === 'object' && field.en) return field.en;
            return null;
          };

          // First pass: collect all items and build recycle map
          for (const file of files) {
            try {
              const data = JSON.parse(fs.readFileSync(path.join(itemsDir, file), 'utf8'));

              const item = {
                id: data.id || path.basename(file, '.json'),
                name: getEnglish(data.name) || 'Unknown',
                type: getEnglish(data.type) || data.type || 'Unknown',
                rarity: getEnglish(data.rarity) || data.rarity || 'Common',
                value: data.value || null,
                weightKg: data.weightKg || null,
                stackSize: data.stackSize || null,
                imageUrl: data.id ? `https://cdn.arctracker.io/items/${data.id}.png` : null,
                recyclesInto: null,
                recycleSources: null
              };

              // Handle recycles_into
              if (data.recyclesInto && Object.keys(data.recyclesInto).length > 0) {
                item.recyclesInto = data.recyclesInto;

                // Build reverse lookup
                for (const [targetId, quantity] of Object.entries(data.recyclesInto)) {
                  if (!recycleMap[targetId]) {
                    recycleMap[targetId] = [];
                  }
                  recycleMap[targetId].push({
                    sourceItemId: item.id,
                    sourceItemName: item.name,
                    yieldsQuantity: quantity
                  });
                }
              }

              items.push(item);
            } catch (e) {
              console.error(`Error processing ${file}:`, e.message);
            }
          }

          // Second pass: add recycleSources to items
          for (const item of items) {
            if (recycleMap[item.id]) {
              item.recycleSources = recycleMap[item.id].sort((a, b) => b.yieldsQuantity - a.yieldsQuantity);
            }
          }

          // Sort items by name
          items.sort((a, b) => a.name.localeCompare(b.name));

          // Read current versions
          let currentVersion = "1.0";
          let currentMapEventsVersion = "1.0";
          let currentEventsVersion = "1.0";
          let currentUpdatedAt = null;
          let currentMapEventsUpdatedAt = null;
          let currentEventsUpdatedAt = null;
          try {
            const versionData = JSON.parse(fs.readFileSync('./version.json', 'utf8'));
            currentVersion = versionData.version || currentVersion;
            currentMapEventsVersion = versionData.mapEventsVersion || currentMapEventsVersion;
            currentEventsVersion = versionData.eventsVersion || currentEventsVersion;
            currentUpdatedAt = versionData.updatedAt || currentUpdatedAt;
            currentMapEventsUpdatedAt = versionData.mapEventsUpdatedAt || currentMapEventsUpdatedAt;
            currentEventsUpdatedAt = versionData.eventsUpdatedAt || currentEventsUpdatedAt;
          } catch (e) {}

          // Check if items changed by comparing item count and checksums
          let itemsChanged = false;
          try {
            const existingData = JSON.parse(fs.readFileSync('./items.json', 'utf8'));
            const existingChecksum = JSON.stringify(existingData.items.map(i => i.id + i.name).sort()).length;
            const newChecksum = JSON.stringify(items.map(i => i.id + i.name).sort()).length;
            itemsChanged = existingData.itemCount !== items.length || existingChecksum !== newChecksum;
          } catch (e) {
            itemsChanged = true; // No existing file
          }

          // Load and compare map events
          const mapEventsPath = './raidtheory-data/map-events/map-events.json';
          let mapEventsChanged = false;
          let mapEvents = null;
          try {
            mapEvents = JSON.parse(fs.readFileSync(mapEventsPath, 'utf8'));
          } catch (e) {
            throw new Error(`Failed to read map events: ${e.message}`);
          }

          try {
            const existingMapEvents = JSON.parse(fs.readFileSync('./map-events.json', 'utf8'));
            mapEventsChanged = JSON.stringify(existingMapEvents) !== JSON.stringify(mapEvents);
          } catch (e) {
            mapEventsChanged = true; // No existing file
          }

          const now = new Date();
          const startDateUtc = new Date(Date.UTC(
            now.getUTCFullYear(),
            now.getUTCMonth(),
            now.getUTCDate(),
            0, 0, 0, 0
          ));
          const eventsDays = 30;
          const eventDurationMinutes = 60;
          const msPerHour = 60 * 60 * 1000;

          const buildEventInstances = (mapEventsData, startDate, days) => {
            const events = [];
            const eventTypes = mapEventsData.eventTypes || {};
            const maps = mapEventsData.maps || {};
            const schedule = mapEventsData.schedule || {};
            const endDateUtc = new Date(startDate.getTime() + days * 24 * msPerHour);

            for (const [mapId, mapSchedule] of Object.entries(schedule)) {
              if (!mapSchedule) continue;
              const mapName = maps[mapId]?.displayName || mapId;

              for (const category of ['major', 'minor']) {
                const hours = mapSchedule[category] || {};
                for (const [hourKey, eventTypeId] of Object.entries(hours)) {
                  if (!eventTypeId || eventTypeId === 'none') continue;
                  const eventType = eventTypes[eventTypeId];
                  if (!eventType || eventType.disabled || eventType.category === 'none') continue;

                  const hour = parseInt(hourKey, 10);
                  if (Number.isNaN(hour)) continue;

                  for (let dayOffset = 0; dayOffset < days; dayOffset++) {
                    const dayDate = new Date(startDate.getTime() + dayOffset * 24 * msPerHour);
                    const startTime = new Date(Date.UTC(
                      dayDate.getUTCFullYear(),
                      dayDate.getUTCMonth(),
                      dayDate.getUTCDate(),
                      hour, 0, 0, 0
                    ));

                    if (startTime < startDate || startTime >= endDateUtc) continue;

                    const endTime = new Date(startTime.getTime() + msPerHour);
                    events.push({
                      eventTypeId,
                      eventName: eventType.displayName || eventTypeId,
                      category: eventType.category || category,
                      mapId,
                      mapName,
                      icon: eventType.icon || null,
                      startTime: startTime.getTime(),
                      endTime: endTime.getTime()
                    });
                  }
                }
              }
            }

            events.sort((a, b) => a.startTime - b.startTime);
            return { events, endDateUtc };
          };

          const { events, endDateUtc } = buildEventInstances(mapEvents, startDateUtc, eventsDays);
          const eventsOutput = {
            generatedAt: startDateUtc.toISOString(),
            startTimeUtc: startDateUtc.toISOString(),
            endTimeUtc: endDateUtc.toISOString(),
            durationMinutes: eventDurationMinutes,
            eventCount: events.length,
            events: events
          };

          let eventsChanged = false;
          try {
            const existingEvents = JSON.parse(fs.readFileSync('./events.json', 'utf8'));
            eventsChanged = JSON.stringify(existingEvents) !== JSON.stringify(eventsOutput);
          } catch (e) {
            eventsChanged = true; // No existing file
          }

          const dataChanged = itemsChanged || mapEventsChanged || eventsChanged;

          if (dataChanged) {
            // Increment versions when data changes
            let newVersion = currentVersion;
            let newMapEventsVersion = currentMapEventsVersion;
            let newEventsVersion = currentEventsVersion;

            if (itemsChanged) {
              const versionParts = currentVersion.split('.');
              const minor = parseInt(versionParts[1] || 0) + 1;
              newVersion = `${versionParts[0]}.${minor}`;
            }

            if (mapEventsChanged) {
              const mapParts = currentMapEventsVersion.split('.');
              const minor = parseInt(mapParts[1] || 0) + 1;
              newMapEventsVersion = `${mapParts[0]}.${minor}`;
            }

            if (eventsChanged) {
              const eventsParts = currentEventsVersion.split('.');
              const minor = parseInt(eventsParts[1] || 0) + 1;
              newEventsVersion = `${eventsParts[0]}.${minor}`;
            }

            // Write items.json
            if (itemsChanged) {
              const database = {
                version: newVersion,
                generatedAt: new Date().toISOString(),
                itemCount: items.length,
                items: items
              };

              fs.writeFileSync('./items.json', JSON.stringify(database, null, 2));
            }

            if (mapEventsChanged) {
              fs.writeFileSync('./map-events.json', JSON.stringify(mapEvents, null, 2));
            }

            if (eventsChanged) {
              fs.writeFileSync('./events.json', JSON.stringify(eventsOutput, null, 2));
            }

            // Write version.json
            const versionInfo = {
              version: newVersion,
              updatedAt: itemsChanged
                ? new Date().toISOString()
                : (currentUpdatedAt || new Date().toISOString()),
              itemCount: items.length
            };

            if (mapEventsChanged || currentMapEventsVersion) {
              versionInfo.mapEventsVersion = newMapEventsVersion;
              versionInfo.mapEventsUpdatedAt = mapEventsChanged
                ? new Date().toISOString()
                : (currentMapEventsUpdatedAt || new Date().toISOString());
            }

            if (eventsChanged || currentEventsVersion) {
              versionInfo.eventsVersion = newEventsVersion;
              versionInfo.eventsUpdatedAt = eventsChanged
                ? new Date().toISOString()
                : (currentEventsUpdatedAt || new Date().toISOString());
            }

            fs.writeFileSync('./version.json', JSON.stringify(versionInfo, null, 2));

            console.log(`Data updated to v${newVersion} with ${items.length} items`);
            fs.writeFileSync('./data_changed.txt', 'true');
          } else {
            console.log('No changes detected');
            fs.writeFileSync('./data_changed.txt', 'false');
          }
          EOF

      - name: Check if data changed
        id: check_changes
        run: |
          if [ -f data_changed.txt ] && [ "$(cat data_changed.txt)" = "true" ]; then
            echo "changed=true" >> $GITHUB_OUTPUT
          else
            echo "changed=false" >> $GITHUB_OUTPUT
          fi
          rm -f data_changed.txt

      - name: Upload to Supabase Storage
        if: steps.check_changes.outputs.changed == 'true'
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          SUPABASE_BUCKET: ${{ secrets.SUPABASE_BUCKET }}
        run: |
          if [ -z "$SUPABASE_URL" ] || [ -z "$SUPABASE_SERVICE_ROLE_KEY" ] || [ -z "$SUPABASE_BUCKET" ]; then
            echo "Supabase secrets missing; skipping upload."
            exit 0
          fi

          upload_file() {
            local file_path="$1"
            local object_path="$2"
            local url="${SUPABASE_URL}/storage/v1/object/${SUPABASE_BUCKET}/${object_path}"
            local status
            status=$(curl -sS -o /dev/null -w "%{http_code}" \
              -X POST "$url" \
              -H "Authorization: Bearer ${SUPABASE_SERVICE_ROLE_KEY}" \
              -H "apikey: ${SUPABASE_SERVICE_ROLE_KEY}" \
              -H "Content-Type: application/json" \
              -H "x-upsert: true" \
              --data-binary @"${file_path}")

            if [ "$status" -lt 200 ] || [ "$status" -ge 300 ]; then
              echo "Upload failed for ${file_path} (HTTP ${status})"
              exit 1
            fi
          }

          upload_file "items.json" "items.json"
          upload_file "version.json" "version.json"
          upload_file "map-events.json" "map-events.json"
          upload_file "events.json" "events.json"

      - name: Commit and push changes
        if: steps.check_changes.outputs.changed == 'true'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add items.json map-events.json events.json version.json
          VERSION=$(node -p "const v=require('./version.json'); 'items ' + v.version + (v.mapEventsVersion ? ', map-events ' + v.mapEventsVersion : '') + (v.eventsVersion ? ', events ' + v.eventsVersion : '')")
          git commit -m "Auto-update game data (${VERSION})"
          git push
