name: Update Game Data

on:
  schedule:
    # Run daily at 3:00 AM UTC
    - cron: '0 3 * * *'
  workflow_dispatch: # Allow manual trigger

permissions:
  contents: write

jobs:
  update-data:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Checkout RaidTheory data
        uses: actions/checkout@v4
        with:
          repository: RaidTheory/arcraiders-data
          path: raidtheory-data

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Process and build database
        run: |
          node << 'EOF'
          const fs = require('fs');
          const path = require('path');

          // Read all item files
          const itemsDir = './raidtheory-data/items';
          if (!fs.existsSync(itemsDir)) {
            throw new Error(`Items directory not found: ${itemsDir}`);
          }

          const files = fs.readdirSync(itemsDir).filter(f => f.endsWith('.json'));
          if (files.length === 0) {
            throw new Error('No item files found in RaidTheory data');
          }

          const items = [];
          const recycleMap = {}; // For reverse lookup

          // Helper to extract English text from localized strings
          const getEnglish = (field) => {
            if (!field) return null;
            if (typeof field === 'string') return field;
            if (typeof field === 'object' && field.en) return field.en;
            return null;
          };

          // First pass: collect all items and build recycle map
          for (const file of files) {
            try {
              const data = JSON.parse(fs.readFileSync(path.join(itemsDir, file), 'utf8'));

              const item = {
                id: data.id || path.basename(file, '.json'),
                name: getEnglish(data.name) || 'Unknown',
                type: getEnglish(data.type) || data.type || 'Unknown',
                rarity: getEnglish(data.rarity) || data.rarity || 'Common',
                value: data.value || null,
                weightKg: data.weightKg || null,
                stackSize: data.stackSize || null,
                imageUrl: data.id ? `https://cdn.arctracker.io/items/${data.id}.png` : null,
                recyclesInto: null,
                recycleSources: null
              };

              // Handle recycles_into
              if (data.recyclesInto && Object.keys(data.recyclesInto).length > 0) {
                item.recyclesInto = data.recyclesInto;

                // Build reverse lookup
                for (const [targetId, quantity] of Object.entries(data.recyclesInto)) {
                  if (!recycleMap[targetId]) {
                    recycleMap[targetId] = [];
                  }
                  recycleMap[targetId].push({
                    sourceItemId: item.id,
                    sourceItemName: item.name,
                    yieldsQuantity: quantity
                  });
                }
              }

              items.push(item);
            } catch (e) {
              console.error(`Error processing ${file}:`, e.message);
            }
          }

          // Second pass: add recycleSources to items
          for (const item of items) {
            if (recycleMap[item.id]) {
              item.recycleSources = recycleMap[item.id].sort((a, b) => b.yieldsQuantity - a.yieldsQuantity);
            }
          }

          // Sort items by name
          items.sort((a, b) => a.name.localeCompare(b.name));

          // Read current versions
          let currentVersion = "1.0";
          let currentMapEventsVersion = "1.0";
          let currentUpdatedAt = null;
          let currentMapEventsUpdatedAt = null;
          try {
            const versionData = JSON.parse(fs.readFileSync('./version.json', 'utf8'));
            currentVersion = versionData.version || currentVersion;
            currentMapEventsVersion = versionData.mapEventsVersion || currentMapEventsVersion;
            currentUpdatedAt = versionData.updatedAt || currentUpdatedAt;
            currentMapEventsUpdatedAt = versionData.mapEventsUpdatedAt || currentMapEventsUpdatedAt;
          } catch (e) {}

          // Check if items changed by comparing item count and checksums
          let itemsChanged = false;
          try {
            const existingData = JSON.parse(fs.readFileSync('./items.json', 'utf8'));
            const existingChecksum = JSON.stringify(existingData.items.map(i => i.id + i.name).sort()).length;
            const newChecksum = JSON.stringify(items.map(i => i.id + i.name).sort()).length;
            itemsChanged = existingData.itemCount !== items.length || existingChecksum !== newChecksum;
          } catch (e) {
            itemsChanged = true; // No existing file
          }

          // Load and compare map events
          const mapEventsPath = './raidtheory-data/map-events/map-events.json';
          let mapEventsChanged = false;
          let mapEvents = null;
          try {
            mapEvents = JSON.parse(fs.readFileSync(mapEventsPath, 'utf8'));
          } catch (e) {
            throw new Error(`Failed to read map events: ${e.message}`);
          }

          try {
            const existingMapEvents = JSON.parse(fs.readFileSync('./map-events.json', 'utf8'));
            mapEventsChanged = JSON.stringify(existingMapEvents) !== JSON.stringify(mapEvents);
          } catch (e) {
            mapEventsChanged = true; // No existing file
          }

          const dataChanged = itemsChanged || mapEventsChanged;

          if (dataChanged) {
            // Increment versions when data changes
            let newVersion = currentVersion;
            let newMapEventsVersion = currentMapEventsVersion;

            if (itemsChanged) {
              const versionParts = currentVersion.split('.');
              const minor = parseInt(versionParts[1] || 0) + 1;
              newVersion = `${versionParts[0]}.${minor}`;
            }

            if (mapEventsChanged) {
              const mapParts = currentMapEventsVersion.split('.');
              const minor = parseInt(mapParts[1] || 0) + 1;
              newMapEventsVersion = `${mapParts[0]}.${minor}`;
            }

            // Write items.json
            if (itemsChanged) {
              const database = {
                version: newVersion,
                generatedAt: new Date().toISOString(),
                itemCount: items.length,
                items: items
              };

              fs.writeFileSync('./items.json', JSON.stringify(database, null, 2));
            }

            if (mapEventsChanged) {
              fs.writeFileSync('./map-events.json', JSON.stringify(mapEvents, null, 2));
            }

            // Write version.json
            const versionInfo = {
              version: newVersion,
              updatedAt: itemsChanged
                ? new Date().toISOString()
                : (currentUpdatedAt || new Date().toISOString()),
              itemCount: items.length
            };

            if (mapEventsChanged || currentMapEventsVersion) {
              versionInfo.mapEventsVersion = newMapEventsVersion;
              versionInfo.mapEventsUpdatedAt = mapEventsChanged
                ? new Date().toISOString()
                : currentMapEventsUpdatedAt;
            }

            fs.writeFileSync('./version.json', JSON.stringify(versionInfo, null, 2));

            console.log(`Data updated to v${newVersion} with ${items.length} items`);
            fs.writeFileSync('./data_changed.txt', 'true');
          } else {
            console.log('No changes detected');
            fs.writeFileSync('./data_changed.txt', 'false');
          }
          EOF

      - name: Check if data changed
        id: check_changes
        run: |
          if [ -f data_changed.txt ] && [ "$(cat data_changed.txt)" = "true" ]; then
            echo "changed=true" >> $GITHUB_OUTPUT
          else
            echo "changed=false" >> $GITHUB_OUTPUT
          fi
          rm -f data_changed.txt

      - name: Commit and push changes
        if: steps.check_changes.outputs.changed == 'true'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add items.json map-events.json version.json
          VERSION=$(node -p "const v=require('./version.json'); 'items ' + v.version + (v.mapEventsVersion ? ', events ' + v.mapEventsVersion : '')")
          git commit -m "Auto-update game data (${VERSION})"
          git push
